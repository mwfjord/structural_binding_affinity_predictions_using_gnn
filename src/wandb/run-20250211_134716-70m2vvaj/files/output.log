Using GPU
Regenerating dataset...
Processing...
0it [00:00, ?it/s]/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/proteinDNADataset.py:99: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at ../torch/csrc/utils/tensor_new.cpp:278.)
  return torch.tensor(residue_features, dtype=torch.float), torch.tensor(pos, dtype=torch.float)
tensor([], size=(2, 0), dtype=torch.int64)
32it [00:07,  2.65it/s]
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
Done!
Regenerating dataset...
Processing...
31it [00:07,  3.57it/s]
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
Done!
Regenerating dataset...
Processing...
31it [00:07,  5.16it/s]
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
tensor([], size=(2, 0), dtype=torch.int64)
Done!
/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/proteinDNADataset.py:179: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  data = torch.load(os.path.join(self.processed_dir,
/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py:104: FutureWarning: `torch.cuda.amp.GradScaler(args...)` is deprecated. Please use `torch.amp.GradScaler('cuda', args...)` instead.
  self.scaler = torch.cuda.amp.GradScaler()
Training:   0%|                                                                                                                                               | 0/18 [00:00<?, ?it/s]/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/nn/modules/loss.py:538: UserWarning: Using a target size (torch.Size([16])) that is different to the input size (torch.Size([16, 1])). This will likely lead to incorrect results due to broadcasting. Please ensure they have the same size.
  return F.mse_loss(input, target, reduction=self.reduction)
Traceback (most recent call last):                                                                                                                                                   
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 260, in <module>
    main()
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 256, in main
    trainer.run()
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 179, in run
    train_loss = self.train_epoch(epoch)
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 127, in train_epoch
    self.scaler.scale(loss).backward()
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/_tensor.py", line 521, in backward
    torch.autograd.backward(
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/autograd/__init__.py", line 289, in backward
    _engine_run_backward(
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/autograd/graph.py", line 768, in _engine_run_backward
    return Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass
RuntimeError: Found dtype Double but expected Float
Traceback (most recent call last):
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 260, in <module>
    main()
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 256, in main
    trainer.run()
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 179, in run
    train_loss = self.train_epoch(epoch)
  File "/home/marcus/programming/structural_binding_affinity_predictions_using_gnn/src/train.py", line 127, in train_epoch
    self.scaler.scale(loss).backward()
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/_tensor.py", line 521, in backward
    torch.autograd.backward(
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/autograd/__init__.py", line 289, in backward
    _engine_run_backward(
  File "/home/marcus/programming/gnn-protein-dna/lib/python3.10/site-packages/torch/autograd/graph.py", line 768, in _engine_run_backward
    return Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass
RuntimeError: Found dtype Double but expected Float
